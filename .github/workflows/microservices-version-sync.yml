name: OnPrem Update Charts - Microservices Version Sync

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (no actual updates)'
        required: false
        default: false
        type: boolean

env:
  APPSTATE_REPO: 'frontegg/AppState'
  TERRAFORM_REPO: 'frontegg/terraform-private-env'
  WORKFLOW_NAME: 'Create Customer Environment'

jobs:
  extract-query-compare:
    name: Extract, Query & Compare Microservices Versions
    runs-on: ubuntu-latest
    outputs:
      has-updates: ${{ steps.compare.outputs.has-updates }}
      summary: ${{ steps.compare.outputs.summary }}
      updates-needed: ${{ steps.compare.outputs.updates-needed }}
    steps:
      - name: Checkout helm-charts repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'scripts/requirements.txt'

      - name: Install dependencies
        run: |
          pip install -r scripts/requirements.txt

      - name: Extract Services
        id: extract
        run: |
          python3 scripts/extract_services.py --verbose

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: frontegg
          repositories: AppState,terraform-private-env
        continue-on-error: false

      - name: Verify Token Generation
        if: steps.app-token.outcome == 'failure'
        run: |
          echo "ðŸš¨ CRITICAL ERROR: GitHub App token generation failed!"
          echo "âŒ This indicates a problem with your GitHub App configuration."
          echo ""
          echo "ðŸ”§ Please check:"
          echo "1. GH_APP_ID secret exists and contains the correct App ID (numeric)"
          echo "2. GH_APP_PRIVATE_KEY secret exists and contains the full PEM private key"
          echo "3. GitHub App exists and is accessible"
          echo "4. Private key matches the GitHub App"
          echo ""
          echo "ðŸ’¡ Common issues:"
          echo "- Private key missing '-----BEGIN PRIVATE KEY-----' header"
          echo "- Private key missing '-----END PRIVATE KEY-----' footer"
          echo "- App ID is incorrect or doesn't exist"
          echo "- Private key was regenerated but secret not updated"
          exit 1

      - name: Debug GitHub App Token
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          echo "=== GitHub App Token Debug Information ==="
          echo "Token length: ${#GITHUB_TOKEN}"
          echo "Token prefix: $(echo $GITHUB_TOKEN | cut -c1-20)..."
          echo "Token type: $(echo $GITHUB_TOKEN | cut -c1-4)"
          echo ""
          
          # Set flag to track if any test fails
          TESTS_FAILED=false
          
          echo "=== Testing GitHub API Access ==="
          # Test authentication
          echo "1. Testing authentication..."
          AUTH_RESPONSE=$(curl -s -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" \
                              -H "Accept: application/vnd.github.v3+json" \
                              https://api.github.com/user)
          HTTP_CODE="${AUTH_RESPONSE: -3}"
          echo "Auth test HTTP code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ Authentication failed"
            echo "Response: $(echo $AUTH_RESPONSE | head -c -4)"
            TESTS_FAILED=true
          else
            echo "âœ… Authentication successful"
            echo "User: $(echo $AUTH_RESPONSE | head -c -4 | jq -r '.login // "unknown"')"
          fi
          echo ""
          
          # Test repository access
          echo "2. Testing repository access to frontegg/AppState..."
          REPO_RESPONSE=$(curl -s -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" \
                              -H "Accept: application/vnd.github.v3+json" \
                              https://api.github.com/repos/frontegg/AppState)
          HTTP_CODE="${REPO_RESPONSE: -3}"
          echo "Repository access HTTP code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ Repository access failed"
            echo "Response: $(echo $REPO_RESPONSE | head -c -4 | jq -r '.message // "No message"')"
            TESTS_FAILED=true
          else
            echo "âœ… Repository access successful"
            REPO_DATA=$(echo $REPO_RESPONSE | head -c -4)
            echo "Repository: $(echo $REPO_DATA | jq -r '.full_name')"
            echo "Private: $(echo $REPO_DATA | jq -r '.private')"
            echo "Permissions: $(echo $REPO_DATA | jq -r '.permissions // "No permissions info"')"
          fi
          echo ""
          
          # Test specific file access
          echo "3. Testing file access..."
          FILE_RESPONSE=$(curl -s -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" \
                              -H "Accept: application/vnd.github.v3+json" \
                              https://api.github.com/repos/frontegg/AppState/contents/applications/admins-service/production-global/values.yaml)
          HTTP_CODE="${FILE_RESPONSE: -3}"
          echo "File access HTTP code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ File access failed"
            echo "Response: $(echo $FILE_RESPONSE | head -c -4 | jq -r '.message // "No message"')"
            TESTS_FAILED=true
          else
            echo "âœ… File access successful"
            echo "File found: applications/admins-service/production-global/values.yaml"
          fi
          echo ""
          
          # Test GitHub App installation
          echo "4. Testing GitHub App installation..."
          INSTALL_RESPONSE=$(curl -s -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" \
                                 -H "Accept: application/vnd.github.v3+json" \
                                 https://api.github.com/repos/frontegg/AppState/installation)
          HTTP_CODE="${INSTALL_RESPONSE: -3}"
          echo "Installation check HTTP code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "âŒ Installation check failed"
            echo "Response: $(echo $INSTALL_RESPONSE | head -c -4 | jq -r '.message // "No message"')"
            TESTS_FAILED=true
          else
            echo "âœ… Installation found"
            INSTALL_DATA=$(echo $INSTALL_RESPONSE | head -c -4)
            echo "Installation ID: $(echo $INSTALL_DATA | jq -r '.id')"
            echo "App ID: $(echo $INSTALL_DATA | jq -r '.app_id')"
            echo "Permissions: $(echo $INSTALL_DATA | jq -r '.permissions')"
          fi
          
          echo ""
          echo "=== Debug Summary ==="
          if [ "$TESTS_FAILED" = true ]; then
            echo "âŒ One or more authentication tests failed!"
            echo "ðŸ›‘ STOPPING WORKFLOW - Fix GitHub App configuration before proceeding"
            echo ""
            echo "Common fixes:"
            echo "1. Check GH_APP_ID secret is correct (numeric value)"
            echo "2. Check GH_APP_PRIVATE_KEY secret contains full PEM content"
            echo "3. Verify GitHub App is installed on frontegg organization"
            echo "4. Ensure GitHub App has Contents:Read and Metadata:Read permissions"
            exit 1
          else
            echo "âœ… All authentication tests passed!"
            echo "ðŸš€ Proceeding with AppState queries..."
          fi

      - name: Query AppState Repository
        id: query
        env:
          GITHUB_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          python3 scripts/query_appstate.py --verbose

      - name: Compare Versions
        id: compare
        run: |
          python3 scripts/compare_versions.py --verbose

      - name: Upload comparison results
        uses: actions/upload-artifact@v4
        with:
          name: comparison-results
          path: comparison_results.json

  update-helm-values:
    name: Update Helm Values Files
    runs-on: ubuntu-latest
    needs: extract-query-compare
    if: needs.extract-query-compare.outputs.has-updates == 'true' && github.event.inputs.dry_run != 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Download comparison results
        uses: actions/download-artifact@v4
        with:
          name: comparison-results

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          pip install -r ${{ github.workspace }}/scripts/requirements.txt

      - name: Update Values Files
        run: |
          python3 scripts/update_values.py --verbose

      - name: Commit changes
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          if git diff --quiet; then
            echo "No changes to commit"
            exit 0
          fi
          
          git add charts/*/values.yaml
          
          # Generate commit message with updated services
          echo "chore: update microservices versions from AppState" > commit_msg.txt
          echo "" >> commit_msg.txt
          echo "Auto-updated microservice versions to match production AppState versions." >> commit_msg.txt
          echo "" >> commit_msg.txt
          echo "Updated services:" >> commit_msg.txt
          python3 -c "
          import json
          with open('comparison_results.json', 'r') as f:
              results = json.load(f)
          for update in results['updates_needed']:
              print(f'- {update[\"service\"]}: {update[\"helm_version\"]} â†’ {update[\"appstate_version\"]}')
          " >> commit_msg.txt
          
          git commit -F commit_msg.txt
          git push

  trigger-deployment:
    name: Trigger Deployment Workflow
    runs-on: ubuntu-latest
    needs: [extract-query-compare, update-helm-values]
    if: needs.extract-query-compare.outputs.has-updates == 'true' && github.event.inputs.dry_run != 'true'
    outputs:
      workflowRunId: ${{ steps.trigger.outputs.workflowRunId }}
      deployToken: ${{ steps.deploy-app-token.outputs.token }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate GitHub App Token for Deployment
        id: deploy-app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: frontegg
          repositories: terraform-private-env

      - name: Trigger terraform-private-env workflow
        id: trigger
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.deploy-app-token.outputs.token }}
          script: |
            try {
              // Trigger the workflow
              const response = await github.rest.actions.createWorkflowDispatch({
                owner: 'frontegg',
                repo: 'terraform-private-env',
                workflow_id: 'Create Customer Environment',
                ref: 'main',
                inputs: {
                  reason: 'Automated microservices version sync',
                  triggered_by: 'helm-charts-version-sync'
                }
              });
              
              console.log('Successfully triggered deployment workflow');
              console.log('Response:', response.status);
              
              // Wait a moment for the workflow to start
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              // Get the latest workflow run
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: 'frontegg',
                repo: 'terraform-private-env',
                workflow_id: 'Create Customer Environment',
                per_page: 1
              });
              
              if (runs.data.workflow_runs.length > 0) {
                const runId = runs.data.workflow_runs[0].id;
                console.log('Workflow run ID:', runId);
                core.setOutput('workflowRunId', runId);
              } else {
                console.log('No workflow runs found');
              }
              
            } catch (error) {
              console.error('Failed to trigger deployment workflow:', error);
              
              // Try with workflow file name if workflow name doesn't work
              try {
                const response = await github.rest.actions.createWorkflowDispatch({
                  owner: 'frontegg',
                  repo: 'terraform-private-env', 
                  workflow_id: 'create-customer-environment.yml',
                  ref: 'main',
                  inputs: {
                    reason: 'Automated microservices version sync',
                    triggered_by: 'helm-charts-version-sync'
                  }
                });
                
                console.log('Successfully triggered deployment workflow with file name');
                console.log('Response:', response.status);
                
                // Wait and get workflow run ID
                await new Promise(resolve => setTimeout(resolve, 5000));
                
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner: 'frontegg',
                  repo: 'terraform-private-env',
                  workflow_id: 'create-customer-environment.yml',
                  per_page: 1
                });
                
                if (runs.data.workflow_runs.length > 0) {
                  const runId = runs.data.workflow_runs[0].id;
                  console.log('Workflow run ID:', runId);
                  core.setOutput('workflowRunId', runId);
                }
                
              } catch (secondError) {
                console.error('Failed to trigger deployment workflow with file name:', secondError);
                throw secondError;
              }
            }

  wait-for-deployment:
    name: Wait for Deployment Completion
    runs-on: ubuntu-latest
    needs: trigger-deployment
    if: needs['trigger-deployment'].outputs.workflowRunId != ''
    outputs:
      deploymentSuccess: ${{ steps.wait.outputs.success }}
    steps:
      - name: Wait for deployment workflow to complete
        id: wait
        uses: actions/github-script@v7
        with:
          github-token: ${{ needs['trigger-deployment'].outputs.deployToken }}
          script: |
            const runId = '${{ needs['trigger-deployment'].outputs.workflowRunId }}';
            const maxWaitTime = 30 * 60 * 1000; // 30 minutes
            const pollInterval = 30 * 1000; // 30 seconds
            const startTime = Date.now();
            
            console.log(`Waiting for workflow run ${runId} to complete...`);
            
            while (Date.now() - startTime < maxWaitTime) {
              try {
                const run = await github.rest.actions.getWorkflowRun({
                  owner: 'frontegg',
                  repo: 'terraform-private-env',
                  run_id: runId
                });
                
                const status = run.data.status;
                const conclusion = run.data.conclusion;
                
                console.log(`Workflow status: ${status}, conclusion: ${conclusion}`);
                
                if (status === 'completed') {
                  if (conclusion === 'success') {
                    console.log('âœ… Deployment workflow completed successfully');
                    core.setOutput('success', 'true');
                    return;
                  } else {
                    console.log(`âŒ Deployment workflow failed with conclusion: ${conclusion}`);
                    core.setOutput('success', 'false');
                    core.setFailed(`Deployment workflow failed: ${conclusion}`);
                    return;
                  }
                }
                
                // Wait before next poll
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                
              } catch (error) {
                console.error('Error checking workflow status:', error);
                await new Promise(resolve => setTimeout(resolve, pollInterval));
              }
            }
            
            console.log('â° Timeout waiting for deployment workflow');
            core.setOutput('success', 'false');
            core.setFailed('Timeout waiting for deployment workflow to complete');

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [extract-query-compare, wait-for-deployment]
    if: needs['wait-for-deployment'].outputs.deploymentSuccess == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download comparison results
        uses: actions/download-artifact@v4
        with:
          name: comparison-results

      - name: Generate release tag
        id: tag
        run: |
          # Generate tag based on current date and time
          TAG="sync-$(date +%Y%m%d-%H%M%S)"
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Generated tag: $TAG"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.tag.outputs.tag }}
          name: "Microservices Version Sync - ${{ steps.tag.outputs.tag }}"
          body: |
            # Microservices Version Sync
            
            This release contains automated updates to microservice versions based on AppState production versions.
            
            ${{ needs.extract-query-compare.outputs.summary }}
            
            ## Changes Made
            - Updated Helm values files with new AppVersion values
            - Synchronized versions with AppState production environment
            
            ## Deployment Status
            âœ… Deployment pipeline completed successfully
            
            ## Workflow Run
            - Triggered deployment workflow: ${{ needs['trigger-deployment'].outputs.workflowRunId }}
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}

  notify-results:
    name: Notify Results
    runs-on: ubuntu-latest
    needs: [extract-query-compare, update-helm-values, trigger-deployment, wait-for-deployment, create-release]
    if: always()
    steps:
      - name: Download comparison results
        uses: actions/download-artifact@v4
        with:
          name: comparison-results
        continue-on-error: true

      - name: Create Job Summary
        run: |
          echo "# Microservices Version Sync Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.extract-query-compare.outputs.has-updates }}" == "true" ]; then
            echo "## âœ… Sync Completed Successfully" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following actions were completed:" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Extracted microservices from Helm charts" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Queried AppState repository for production versions" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Compared versions and identified updates needed" >> $GITHUB_STEP_SUMMARY
            
            if [ "${{ github.event.inputs.dry_run }}" != "true" ]; then
              echo "- âœ… Updated Helm values files" >> $GITHUB_STEP_SUMMARY
              echo "- âœ… Triggered deployment workflow" >> $GITHUB_STEP_SUMMARY
              
              if [ "${{ needs['wait-for-deployment'].outputs.deploymentSuccess }}" == "true" ]; then
                echo "- âœ… Deployment completed successfully" >> $GITHUB_STEP_SUMMARY
                echo "- âœ… Created GitHub release" >> $GITHUB_STEP_SUMMARY
              else
                echo "- âŒ Deployment failed or timed out" >> $GITHUB_STEP_SUMMARY
                echo "- â­ï¸ Skipped release creation" >> $GITHUB_STEP_SUMMARY
              fi
            else
              echo "- â­ï¸ Skipped updates (dry-run mode)" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "## â„¹ï¸ No Updates Needed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All microservices are already up to date with AppState production versions." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Add detailed summary if available
          if [ -f "comparison_results.json" ]; then
            echo "## Detailed Results" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            python3 -c "
            import json
            try:
                with open('comparison_results.json', 'r') as f:
                    results = json.load(f)
                print(results['summary'])
            except:
                print('Summary not available')
            " >> $GITHUB_STEP_SUMMARY
          fi
